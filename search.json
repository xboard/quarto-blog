[
  {
    "objectID": "posts/2023_07_27_tip_set_dependsonpast_in_airflow_when_creating_time_series_model_pipeline/index.html",
    "href": "posts/2023_07_27_tip_set_dependsonpast_in_airflow_when_creating_time_series_model_pipeline/index.html",
    "title": "Tip: set depends_on_past=True in Airflow when creating a time series model pipeline",
    "section": "",
    "text": "Tip\n\n\n\nWhen creating time series model pipeline in Airflow set depends_on_past=True."
  },
  {
    "objectID": "posts/2023_07_27_tip_set_dependsonpast_in_airflow_when_creating_time_series_model_pipeline/index.html#how",
    "href": "posts/2023_07_27_tip_set_dependsonpast_in_airflow_when_creating_time_series_model_pipeline/index.html#how",
    "title": "Tip: set depends_on_past=True in Airflow when creating a time series model pipeline",
    "section": "How?",
    "text": "How?\nFor a specific task, most probably a sensor:\ntask = SomeSensor(\n    task_id='task',\n    depends_on_past=True,\n    # ...\n)\nor in your dag default_args to enable depends_on_past for all your tasks\ndefault_args = {\n    'depends_on_past': True,\n    # ...\n}\n\ndag = DAG(\n    dag_id=\"time_series_pipeline\",\n    default_args=default_args,\n    # ...\n)"
  },
  {
    "objectID": "posts/2023_07_27_tip_set_dependsonpast_in_airflow_when_creating_time_series_model_pipeline/index.html#why",
    "href": "posts/2023_07_27_tip_set_dependsonpast_in_airflow_when_creating_time_series_model_pipeline/index.html#why",
    "title": "Tip: set depends_on_past=True in Airflow when creating a time series model pipeline",
    "section": "Why?",
    "text": "Why?\nTime series models help us predict future data based on patterns and trends observed in historical data. These models depend on the order and timing of data, hence any deviation from the expected sequence can affect their accuracy.\nOne way to ensure the integrity of the sequence of data while creating time series models in Apache Airflow is to set the depends_on_past argument to True. This argument enables the Directed Acyclic Graph (DAG) for the time series model to run in the order of dependency on past data. By doing so, it ensures that the historical data used to train the models is in correct order and the models receive the correct inputs in the correct order.\nIn other words, with depends_on_past=True, each subsequent task in the DAG will only run once its preceding task has completed successfully. This approach guarantees that the time series model is fed with the correct inputs in the correct order and that the historical data is correctly sequenced, resulting in better forecasting accuracy and reliability.\nTherefore, enabling depends_on_past for your tasks or whole DAG is an essential practice when creating time series models in Apache Airflow. By doing so, we can create more accurate and reliable time series models that can better predict future data based on past patterns and trends."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "xboard.dev",
    "section": "",
    "text": "Tip: set depends_on_past=True in Airflow when creating a time series model pipeline\n\n\n\n\n\n\n\nairflow\n\n\ndata engineering\n\n\n\n\n\n\n\n\n\n\n\nJul 27, 2023\n\n\nFlavio Regis de Arruda\n\n\n\n\n\n\n  \n\n\n\n\nUsing pip-tools to manage project dependencies in Python\n\n\n\n\n\n\n\nsoftware development\n\n\ntools\n\n\npython\n\n\n\n\nHow to ensure you have a reproducible development environment.\n\n\n\n\n\n\nJul 20, 2023\n\n\nFlavio Regis de Arruda\n\n\n\n\n\n\n  \n\n\n\n\nInterrupted Time Series (ITS) in Python\n\n\n\n\n\n\n\ndata science\n\n\ncausal inference\n\n\npython\n\n\n\n\nInterrupted Time Series (ITS) analysis using Python and statsmodels.\n\n\n\n\n\n\nJan 1, 2022\n\n\nFlavio Regis de Arruda\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#when-ab-test-is-not-an-option",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#when-ab-test-is-not-an-option",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "When A/B test is not an option",
    "text": "When A/B test is not an option\nThe gold standard for statistically asserting the effectiveness of an intervention is the randomized controlled experiment and its simplified online variant: the A/B test.\n\nüìù During an A/B test there are two almost identical versions of a product, simultaneously running, that only differ by the hypothesis you want to test ( i.e can a red call to action button convert more than a blue one? ). Users are randomly chosen to experience one (and only one) of the two versions while the experiment is active.\n\nThey are easy to understand, easy to setup (great free tools easily available) and when correctly designed they rule out any covariate differences between the groups.\nHowever, sometimes it‚Äôs just not possible to set up an A/B test:\n\nTechnical difficulties. Sometimes a change is so widespread and complex that it would be technically impossible to keep two different versions running simultaneously.\nBusiness strategy. A new feature rollout will be available first to some countries and later for others.\nEthical concerns. Having a subset of customers having access to a feature or bug fix that gives them a competitive advantage over others that don‚Äôt.\nLegal or regulatory requirements. A change in regulations becomes mandatory ( i.e.¬†GPDR compliance ) and should be applied to all your customers of a given country at the same time.\nTemporal infeasibility. You want to analyze an event that has already happened ( i.e.¬†How last Google‚Äôs search algorithm update impacted your sales funnel? )."
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#quasi-experiments",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#quasi-experiments",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "Quasi Experiments",
    "text": "Quasi Experiments\n   \nIf you can‚Äôt do an A/B test then the second to best alternative are quasi experiments [1].\nIn a quasi experiment, your treatment and control group are not divided by a completely random process but by a natural process (i.e.¬†time, location, etc) therefore there is a much larger chance for imbalance due to skewness and heterogeneous differences. The results of a quasi-experiment won‚Äôt be as precise as an A/B, but if carefully conducted could be considered close enough to compute estimates.\nThere are some scenarios, like some described in the previous section, where having a control group in parallel to a test group is just not possible, and this is when Interrupted Times Series comes in very handy."
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#interrupted-time-series-its",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#interrupted-time-series-its",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "Interrupted Time Series (ITS)",
    "text": "Interrupted Time Series (ITS)\nInterrupted time series (ITS) is a method of statistical analysis involving tracking a period before and after a intervention at a known point in time to assess the intervention‚Äôs effects within a single group/population. The time series refers to the data over the period, while the interruption is the intervention, which is a controlled external influence or set of influences. Effects of the intervention are evaluated by changes in the level and slope of the time series and statistical significance of the intervention parameters [2]. The more observations you have before and after the intervention, the more robust your model will be (typically). Because the evaluation is based on observing a single population over time, the ITS design is free from problems due to between-group difference but are susceptible to time-varying confounders like other interventions occurring around the time of the intervention that may also affect the outcome [3].\n  \n\nüëç Strengths of Interrupted Time Series include the ability to control for secular trends in the data (unlike a 2-period before-and-after \\(t\\)-test), ability to evaluate outcomes using population-level data, clear graphical presentation of results, ease of conducting stratified analyses, and ability to evaluate both intended and unintended consequences of interventions.\nüëé Limitations of Interrupted Time Series include the need for a minimum of 8 time periods before and 8 after an intervention to evaluate changes statistically, difficulty in analyzing the independent impact of separate components of a program that are implemented close together in time, and existence of a suitable control population.\n\nIn mathematical terms, it means that the time series equation \\((1)\\) includes four key coefficients:\n \\[Y = b_0 + b_1T + b_2D + b_3P + \\epsilon\\] \nWhere:\n\\(Y\\) is the outcome variable;\n\\(T\\) is a continuous variable which indicates the time passed from start of the observational period;\n\\(D\\) is a dummy variable indicating observation collected before (\\(D=0\\)) or after (\\(D=1\\)) the intervention;\n\\(P\\) is a continuous variable indicating time passed since the intervention has occurred (before intervention has occurred \\(P\\)is equal to \\(0\\));\nWith \\(\\epsilon\\) representing a zero centered gaussian random error.\n\nCounterfactual\n  \n\nWhat would have happened had Neo chosen the blue pill?\n\nIn an ITS it is important to understand the counterfactual. The counterfactual refers to what it would have occurred to Y, had the policy intervention not happened.\n\nüìùCounterfactuals are simply ways of comparing what happens given a change, versus what should have happened had some change not occurred in the first place.\n\nIn a randomized trial or A/B test we know the counterfactual average outcome because the experiment withheld the intervention from the control group (which by randomization is somewhat the same as the intervention group). A critical assumption in ITS is that the outcome of interest trend would remain unchanged in the absence of intervention."
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#a-practical-example",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#a-practical-example",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "A practical example",
    "text": "A practical example\nBob runs a large and successful blog on personal finance. During a webinar he learns that making his web content load faster could reduce its bounce rate and therefore decides to sign up for a CDN service. It‚Äôs been 6 months since he added a CDN to his blog and he wants to know if the investiment he did reduced the bounce rate.\n\nDataset\nBob provides us with üíæ 24 weeks of data before adding the CDN and 24 weeks after it (intervention). Therefore, weeks 1 to 24 have a bouncing rate before intervention and weeks 25 to 48 after it.\n\n  \n\nVisually, it looks like after enabling the CDN the bounce rate decreased, but by how much, and does it have statistical significance? To answer this question using interrupted time series analysis, we first need to prepare our data.\n\n\nDataset preparation\nUsing equation (1) notation we üíæ enrich this data with values for columns \\(D\\) (\\(0\\) = before intervention, \\(1\\) after) and \\(P\\) (number of weeks since intervention started):\n\n\n\n\n\n\n\n\n\nBouncing rate(Y)\nWeek (T)\nIntervention(D)\nIntervention week(P)\n\n\n\n\n12.92\n1\n0\n0\n\n\n13.03\n2\n0\n0\n\n\n13.06\n3\n0\n0\n\n\n13.17\n4\n0\n0\n\n\n‚Ä¶\n‚Ä¶\n‚Ä¶\n‚Ä¶\n\n\n12.04\n45\n1\n21\n\n\n12.45\n46\n1\n22\n\n\n12.74\n47\n1\n23\n\n\n12.57\n48\n1\n24"
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#naive-solution",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#naive-solution",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "Naive solution",
    "text": "Naive solution\nLet‚Äôs implement an ordinary least squares (OLS) regression using statsmodels to measure the impact of our intervention:\nimport pandas as pd\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\n\ndf = pd.read_csv(\"enriched_data.csv\")\n\nmodel = smf.ols(formula='Y ~ T + D + P', data=df)\nres = model.fit()\nprint(res.summary())\nWith output:\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:                      Y   R-squared:                       0.666\nModel:                            OLS   Adj. R-squared:                  0.643\nMethod:                 Least Squares   F-statistic:                     29.18\nDate:                Tue, 28 Dec 2021   Prob (F-statistic):           1.52e-10\nTime:                        14:33:50   Log-Likelihood:                 4.8860\nNo. Observations:                  48   AIC:                            -1.772\nDf Residuals:                      44   BIC:                             5.713\nDf Model:                           3                                         \nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          t      P&gt;|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept     12.9100      0.096    134.225      0.000      12.716      13.104\nT              0.0129      0.007      1.920      0.061      -0.001       0.026\nD             -0.5202      0.132     -3.942      0.000      -0.786      -0.254\nP             -0.0297      0.010     -3.115      0.003      -0.049      -0.010\n==============================================================================\nOmnibus:                        3.137   Durbin-Watson:                   0.665\nProb(Omnibus):                  0.208   Jarque-Bera (JB):                1.995\nSkew:                           0.279   Prob(JB):                        0.369\nKurtosis:                       2.172   Cond. No.                         125.\n==============================================================================\n\n\nThe model estimates that the bounce rate decreased üîª 0.52% and this effect is statistically significant (\\(P&gt;|t|\\) is virtually zero).\nIt is also noteworth that the model estimates a small (on average üîª 0.0297%) but with statistical significance trend of a decrease in bounce rate each week after intervention, which is unexpected since the CDN serves the whole website just a few hours after activation.\nThe figure below depicts how the model fits before and after intervention and how it project a counterfactual would be:\n\nstart = 24\nend = 48\nbeta = res.params\n\n# Get model predictions and 95% confidence interval\npredictions = res.get_prediction(df)\nsummary = predictions.summary_frame(alpha=0.05)\n\n# mean predictions\ny_pred = predictions.predicted_mean\n\n# countefactual assumes no interventions\ncf_df = df.copy()\ncf_df[\"D\"] = 0.0\ncf_df[\"P\"] = 0.0\n\n# counter-factual predictions\ncf = res.get_prediction(cf_df).summary_frame(alpha=0.05)\n\n# Plotting\nplt.style.use('seaborn-whitegrid')\nfig, ax = plt.subplots(figsize=(16,10))\n\n# Plot bounce rate data\nax.scatter(df[\"T\"], df[\"Y\"], facecolors='none', edgecolors='steelblue', label=\"bounce rate data\", linewidths=2)\n\n# Plot model mean bounce rate prediction\nax.plot(df[\"T\"][:start], y_pred[:start], 'b-', label=\"model prediction\")\nax.plot(df[\"T\"][start:], y_pred[start:], 'b-')\n\n# Plot counterfactual mean bounce rate with 95% confidence interval\nax.plot(df[\"T\"][start:], cf['mean'][start:], 'k.', label=\"counterfactual\")\nax.fill_between(df[\"T\"][start:], cf['mean_ci_lower'][start:], cf['mean_ci_upper'][start:], color='k', alpha=0.1, label=\"counterfactual 95% CI\");\n\n# Plot line marking intervention moment\nax.axvline(x = 24.5, color = 'r', label = 'intervention')\n\nax.legend(loc='best')\nplt.ylim([10, 15])\nplt.xlabel(\"Weeks\")\nplt.ylabel(\"Bounce rate (%)\");\n\n  \n\n\nProblems with naive approach\n\n  \n\nOLS (Ordinary Least Squares) regression has seven main assumptions but for brevity in this article we will focus on two only:\n\nIndividual observations are independent.\nResiduals follow a normal distribution.\n\n\nLet‚Äôs first check for the normality of residuals:\nWe can apply the Jarque-Bera test on residuals to checks whether their skewness and kurtosis match a normal distribution (\\(H_0\\): residual distribution follows a normal distribution). Our statsmodels OLS summary output shows a Prob(JB): 0.369 which for a standard \\(\\alpha\\) level of 0.05 doesn‚Äôt allow us discard null hypothesis (\\(H_0\\)).\nLet‚Äôs plot the distribution of residuals:\n    res.resid.plot(kind=\"kde\")\n\n  \n\nWhich for a small dataset (less than 50 points) looks sufficiently gaussian.\nOverall, the assumption of normality of residuals can‚Äôt be convincingly refuted. ‚úÖ\n\n\nChecking independence of observations:\nThe Durbin-Watson statistic test if the residuals are correlated with its immediate predecessor, that is, if they have an autocorrelation at lag 1 or \\(AR(1)\\). Its value ranges from 0 to 4 and values smaller than 1.5 indicate a positive autocorrelation, while values greater than 2.5 signal a negative autocorrelation.\nIf we take a look again at our OLS summary output we will observe that the Durbin-Watson statistic has a value of 0.665 which signals a strong positive \\(AR(1)\\).\nLet‚Äôs plot the residuals to see if we can observe this autocorrelation:\nimport altair as alt\n\nrules = alt.Chart(pd.DataFrame({\n  'residuals': [0.0],\n  'color': ['black']\n})).mark_rule().encode(\n  y='residuals',\n  color=alt.Color('color:N', scale=None)\n)\n\nresidual_plot = alt.Chart(res_df).mark_point().encode(\n    x=alt.X('Weeks'),\n    y=alt.Y('residuals')\n)\n\nrules + residual_plot \n\n  \n\nNotice how residuals above/below zero have most points temporally close to it also above/below zero as well, which goes against the independence of observations assumption of OLS ‚ùå.\n\nüìùIn practice when analyzing time series data the presence of autocorrelation is the rule instead of the exception since in general the factors that contributed to a given observation tend to persist for a while."
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#autoregressive-model-solution",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#autoregressive-model-solution",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "Autoregressive model solution",
    "text": "Autoregressive model solution\nThe autoregressive model specifies that each observation depends linearly on previous observations.\nThus, an autoregressive model of order \\(p\\) (\\(AR(p)\\)) can be written as\n \\[y_t = c + \\phi_1 y_{t-1}+ \\dots + \\phi_p y_{t-p} + \\epsilon_t\\] \nWhere:\n\\(y_t\\): observation at time \\(t\\),\n\\(y_{t-i}\\): observation at time \\(t - i\\),\n\\(\\phi_i\\): coefficient of how much observation \\(y_{t - i}\\) correlates to \\(y_t\\),\n\\(\\epsilon_t\\): white noise ( \\(\\mathcal{N}(0, \\sigma¬≤)\\) ) at time \\(t\\).\n\nAutocorrelation\nTo assess how much an observation correlates with past observations it is useful to do an autocorrelation plot as shown below:\nsm.graphics.tsa.plot_acf(res.resid, lags=10)\nplt.show()\n\n  \n\n\n\nPartial Autocorrelation\nThe partial autocorrelation at lag \\(p\\) is the correlation that results after removing the effect of any correlations due to the terms at shorter lags.\nsm.graphics.tsa.plot_pacf(res.resid, lags=10)\nplt.show()   \n\n  \n\n\n\nModel selection\nThe theory states that in an autoregressive model its autocorrelation plot should depict an exponential decay and the number of lags \\(p\\) should be taken from the partial autocorrelation chart using its \\(p\\) most relevant lags. Applying the theory to our plots above, we conclude that our model is autoregressive of lag 1 also known as AR(1).\n\n\nARIMA\nIn statistics ARIMA stands for autoregressive integrated moving average model and as can be inferred by the name AR models are as especial case of ARIMA therefore AR(1) is equivalent to ARIMA(1,0,0).\nWe can model an AR(1) process to our dataset using statsmodels ARIMA as below:\nfrom statsmodels.tsa.arima.model import ARIMA\n\narima_results = ARIMA(df[\"Y\"], df[[\"T\",\"D\",\"P\"]], order=(1,0,0)).fit()\nprint(arima_results.summary())\nOutput:\n                               SARIMAX Results                                \n==============================================================================\nDep. Variable:                      Y   No. Observations:                   48\nModel:                 ARIMA(1, 0, 0)   Log Likelihood                  18.574\nDate:                Thu, 30 Dec 2021   AIC                            -25.148\nTime:                        01:51:46   BIC                            -13.921\nSample:                             0   HQIC                           -20.905\n                                 - 48                                         \nCovariance Type:                  opg                                         \n==============================================================================\n                 coef    std err          z      P&gt;|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nconst         12.9172      0.279     46.245      0.000      12.370      13.465\nT              0.0121      0.016      0.767      0.443      -0.019       0.043\nD             -0.5510      0.273     -2.018      0.044      -1.086      -0.016\nP             -0.0238      0.021     -1.155      0.248      -0.064       0.017\nar.L1          0.6635      0.138      4.803      0.000       0.393       0.934\nsigma2         0.0267      0.006      4.771      0.000       0.016       0.038\n===================================================================================\nLjung-Box (L1) (Q):                   1.00   Jarque-Bera (JB):                 0.15\nProb(Q):                              0.32   Prob(JB):                         0.93\nHeteroskedasticity (H):               1.44   Skew:                            -0.05\nProb(H) (two-sided):                  0.47   Kurtosis:                         3.25\n===================================================================================\nThe autoregressive model estimates that the bounce rate decreased üîª 0.55% on average and this effect is statistically significant (\\(P&gt;|t| = 4.4\\%\\), less than our \\(\\alpha = 5\\%\\)).\nHowever, unlike the previous OLS model, the autoregressive model does not estimate a statistical significance trend of a decrease in bounce rate each week after intervention, which is in line with our expectations.\nThe models estimates (with counterfactual projections) can be seen in the chart below:\n\nfrom statsmodels.tsa.arima.model import ARIMA\n\nstart = 24\nend = 48\n\npredictions = arima_results.get_prediction(0, end-1)\nsummary = predictions.summary_frame(alpha=0.05)\n\narima_cf = ARIMA(df[\"Y\"][:start], df[\"T\"][:start], order=(1,0,0)).fit()\n\n# Model predictions means\ny_pred = predictions.predicted_mean\n\n# Counterfactual mean and 95% confidence interval\ny_cf = arima_cf.get_forecast(24, exog=df[\"T\"][start:]).summary_frame(alpha=0.05)\n\n# Plot section\nplt.style.use('seaborn-whitegrid')\nfig, ax = plt.subplots(figsize=(16,10))\n\n# Plot bounce rate data\nax.scatter(df[\"T\"], df[\"Y\"], facecolors='none', edgecolors='steelblue', label=\"bounce rate data\", linewidths=2)\n\n# Plot model mean bounce prediction\nax.plot(df[\"T\"][:start], y_pred[:start], 'b-', label=\"model prediction\")\nax.plot(df[\"T\"][start:], y_pred[start:], 'b-')\n\n# Plot counterfactual mean bounce rate with 95% confidence interval\nax.plot(df[\"T\"][start:], y_cf[\"mean\"], 'k.', label=\"counterfactual\")\nax.fill_between(df[\"T\"][start:], y_cf['mean_ci_lower'], y_cf['mean_ci_upper'], color='k', alpha=0.1, label=\"counterfactual 95% CI\");\n\n\n# Plot line marking intervention moment\nax.axvline(x = 24.5, color = 'r', label = 'intervention')\n\nax.legend(loc='best')\nplt.ylim([10, 15])\nplt.xlabel(\"Weeks\")\nplt.ylabel(\"Bounce rate (%)\");\n\n  \n\nWe can clearly see that the ARIMA(1, 0, 0) model fits our dataset better than the OLS model.\n\n\nARIMA residual analysis\nThe summary of our autoregressive model shows a Prob(JB): 0.93 which is compatible with the null-hypothesis of normaly distributed residuals. ‚úÖ\nThe Ljung-Box Q test verifies whether the residuals are independently distributed (they exhibit no serial autocorrelation) as \\(H_0\\) (null-hypothesis). As the Prob(Q): 0.32 is way above the standard \\(\\alpha = 0.05\\) there is no evidence of serial autocorrelation in the ARIMA residuals. ‚úÖ\nLet‚Äôs now take a look at residuals qqplot to check if they follow a normal distribution:\n\nimport scipy as sp\nfrom statsmodels.graphics.gofplots import qqplot\n\nfig, (ax1, ax2) = plt.subplots(1,2, figsize=(16,8))\nsm.qqplot(res.resid, sp.stats.t, fit=True, line=\"45\", ax=ax1);\nax1.set_title(\"OLS qqplot\");\n\nsm.qqplot(arima_results.resid, sp.stats.t, fit=True, line=\"45\", ax=ax2);\nax2.set_title(\"ARIMA qqplot\");\nplt.show();\n\n  \n\nWe may observe that the ARIMA(1,0,0) model residuals not only are in general normally distributed as they fit better than the OLS model the theoretical quantiles. ‚úÖ"
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#summary",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#summary",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "Summary",
    "text": "Summary\nA/B tests are a the most powerful and trustworthy method to do measure the impact of modifications/changes even before they are fully implemented, which is why they are so widely used.\nHowever, there are some scenarios where A/B tests are not feasible and this is when the knowledge of quasi-experiments becomes valuable to get statistically sound measurements of change impact.\nIn this post we have shown why an ordinary least square (OLS) linear regression is not a good modeling approach for time series data since they usualy present non-negligible autocorrelation that violates some assumptions of OLS.\nWe demonstrated with an example how to use python (statsmodels, matplotlib, altair and pandas) to visualize residuals and plot autocorrelation and partial autocorrelations charts to figure out the lag of an autoregressive model and then implemented a ARIMA model using statsmodels to observed a more accurate and precise analysis and how to interpret statsmodels model output for OLS and ARIMA.\nWe also showed how to plot in a single chart the models estimates (mean and 95% confidence interval) for the time periods before and after intervention and its respective counterfactual."
  },
  {
    "objectID": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#references",
    "href": "posts/2020_01_01_interrupted-time-series-python-part-I/index.html#references",
    "title": "Interrupted Time Series (ITS) in Python",
    "section": "References",
    "text": "References\n[1] Shopify Engineering: How to Use Quasi-experiments and Counterfactuals to Build Great Products.\n[2] Wikipedia: Interrupted Time Series.\n[3] Campbell DT, Stanley JC. Experimental and Quasi-experimental Designs for Research. Boston, MA: Houghton Mifflin, 1963."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "",
    "text": "As a engineer who loves to solve problems using Python and creates tens of projects by year, keeping track of different packages and their versions can be complex. That is why I use the pip-tools project to simplify the process of package dependency management. In this blog post, we will discuss what pip-tools does, the problem it solves and why developers should consider using it, and provide five examples using pip-tools for managing Python project dependencies. Additionally, we will explore some alternatives to pip-tools."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#simplify-your-python-dependency-management-with-pip-tools",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#simplify-your-python-dependency-management-with-pip-tools",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "",
    "text": "As a engineer who loves to solve problems using Python and creates tens of projects by year, keeping track of different packages and their versions can be complex. That is why I use the pip-tools project to simplify the process of package dependency management. In this blog post, we will discuss what pip-tools does, the problem it solves and why developers should consider using it, and provide five examples using pip-tools for managing Python project dependencies. Additionally, we will explore some alternatives to pip-tools."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#what-is-pip-tools",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#what-is-pip-tools",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "What is pip-tools?",
    "text": "What is pip-tools?\npip-tools is an open-source project created to simplify the requirements files management used in Python projects. It takes a project‚Äôs dependencies and recursively generates pinned version requirement files.\nMoreover, pip-tools allows you to easily manage your project dependencies with minimum effort and ensures you have a reproducible development environment. It allows other developers that are working on the same project to have identical dependencies to yours, with no version conflicts.\nThis can help reduce time spent debugging issues related to package conflicts and ensure that code runs consistently across different environments."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#what-problem-does-pip-tools-solve",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#what-problem-does-pip-tools-solve",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "What problem does pip-tools solve?",
    "text": "What problem does pip-tools solve?\nDependency management in Python projects can be challenging, especially when dealing with multiple environments and package versions. Developers need a tool that can simplify the generation and maintenance of requirements files, ensure that all packages are pinned to a specific version to avoid version conflicts, and provide an easier way to manage different environments."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#why-and-when-should-developers-use-pip-tools",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#why-and-when-should-developers-use-pip-tools",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "Why and when should developers use pip-tools?",
    "text": "Why and when should developers use pip-tools?\nSimplifying dependency management can minimize errors and save valuable development time. Developers should consider using pip-tools in their Python projects because:\n\nIt streamlines the generation and maintenance of requirements files\nIt ensures that all packages are pinned to a specific version to avoid version conflicts\nIt provides an easier way to manage different environments, like production, development, and testing\nIt permits simple package updating and upgrading as new versions become available"
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#example-of-using-pip-tools",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#example-of-using-pip-tools",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "Example of using pip-tools",
    "text": "Example of using pip-tools\nHere are five examples of how developers can use pip-tools to manage the package requirements of their Python projects:\n\nBasic usage of pip-tools with requirements files\nDevelopers can use pip-tools to manage their project dependencies by creating a requirements.in file with the required packages and their respective versions. Developers can then run the following command to generate the required requirements.txt file:\n$ pip-compile requirements.in\nThis generates a pinned version requirement file with all the packages and their respective dependencies.\n\n\npip-tools with multiple environments\nDevelopers can define several files with libraries to use in multiple environments, such as development, production, and testing. They can create corresponding dev-requirements.in, prod-requirements.in, and test-requirements.in files and then use the following commands to generate their respective files:\n$ pip-compile dev-requirements.in\n$ pip-compile prod-requirements.in\n$ pip-compile test-requirements.in\nThese commands will generate dev-requirements.txt, prod-requirements.txt, and test-requirements.txt files with the corresponding dependencies.\n\n\npip-tools with custom package indexes\nDevelopers can also use pip-tools with package indexes different from the official PyPI index. To do this, they can specify a custom index in their requirements.in file, like this:\n--index-url https://custompackageindex.com/\ndjango==3.2.5\nThen, running pip-compile requirements.in will output a requirements.txt file with the packages pinned to versions on the custom package index.\n\n\npip-tools with transitive dependencies\nDevelopers may also encounter transitive dependencies, which are dependencies from required packages. To manage these dependencies, developers can use pip-tools with the following command:\n$ pip-compile --generate-hashes requirements.in\nThis will add a hash value to each package in the requirements file, including the transitive dependencies.\n\n\npip-tools to update dependencies\nFinally, pip-tools can also help developers manage package updates easily. They can run the following command to generate a requirements.txt file with the new versions of the packages:\n$ pip-compile --upgrade requirements.in \nThis command will identify the available updates and upgrade the packages listed in the requirements file."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#pip-sync",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#pip-sync",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "pip-sync",
    "text": "pip-sync\npip-sync is a tool provided by pip-tools that ensures your virtual environment only contains the packages you have explicitly listed in your requirements.txt file. This is useful because it prevents conflicts between versions of packages in your virtual environment and ensures you only install the packages necessary for your project.\nUsing pip-sync is a good practice to ensure your project dependencies are isolated from other projects on your development machine. It prevents conflicts between different versions of packages, making your project more reliable and robust.\nOnce you have your requirements.txt file, run the command:\n$ pip-sync\nThis command will install only the packages listed in requirements.txt and their dependencies, and remove any packages that are not listed. This ensures that you have an isolated environment with only the packages required by your project."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#alternatives-to-pip-tools",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#alternatives-to-pip-tools",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "Alternatives to pip-tools",
    "text": "Alternatives to pip-tools\nWhile pip-tools is a popular and powerful tool for managing dependencies, developers can also use alternatives such as Poetry, Pipenv, conda, and setuptools. These tools all have slightly different approaches to the problem of managing package dependencies in Python projects but pip-tools has the advantage of being simpler and more lightweight while for instance poetry is preferable if you also want a more complete set of features for managing not only package dependencies, but also virtual environments, package building, and publishing."
  },
  {
    "objectID": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#conclusion",
    "href": "posts/2023_07_20_using_pip_tools_to_manage_python_project_dependencies/index.html#conclusion",
    "title": "Using pip-tools to manage project dependencies in Python",
    "section": "Conclusion",
    "text": "Conclusion\npip-tools provides developers with an elegant and straightforward way to manage package dependencies in their Python projects. With its advantages such as generating pinned versions, managing multiple environments, and identifying available package updates, it simplifies the work of maintaining Python projects. By using pip-tools with different commands like pip-compile and pip-sync, developers can effectively solve the problem of managing their project dependencies."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hey üëã, I am Flavio Regis de Arruda.\nI am a backend and data engineer who resides in Brazil üáßüá∑. With over 20 years of experience in backend and data science, I have cultivated a great passion for managing, manipulating and analyzing data in order to gain better insights and ultimately improve the world.\nIn my free time, I enjoy spending time with my two children, playing chess, traveling and watching movies. As I believe in the importance of maintaining a balance between work and personal life, I make sure to incorporate daily exercise into my routine. Additionally, I like to walk in nature at least once a week to recharge my energies."
  }
]